
#―――――――――――――――――――――――――――――――――――――  函数  ―――――――――――――――――――――――――――――――――――――#


#编写函数：
#fun_name <- function(arg1, arg2= default, ...){
#  控制流（顺序结构、分支结构、循环结构）
#  return（返回值）
#}

#R里面一切都是对象，对象是通过赋值产生， 函数也是如此
#函数声明关键字是function，function返回值就是函数
#参数列表以逗号分隔，函数主体可以是任何合法的R表达式
#弱若无return语句，最后一行代码的返回值即作为函数的返回值
#以fun_name(arg1, arg2, ...)的形式调用函数

# '?' + 函数名可查看help
#直接输入函数名以查看源代码


#――――――――――――――――――――――――――――――――――  编写函数：勾股定理  ――――――――――――――――――――――――――――――――――#


rm(list = ls())

pythagorean <- function(a, b){              #参数a和b作为输入
  c <- a^2 + b^2                            #对输入结果进行处理
  c <- c^0.5                                #对输入结果进行处理
  return(c)                                 #返回处理结果
}

pythagorean(3, 4)                           #位置参数
pythagorean(b = 3, a = 4)                   #名义参数(推荐)


# ... 可以包含任意多的参数，它通常在参数个数未知，或者某些参数会传递给其他函数的情况下使用

example1 <- function(...){
  cat('Second:', ..2,'\n')                  #第二个参数
  org.list <- list(...)
  org.list <- unlist(org.list)              #通过list函数来捕捉所有的参数
  org.list <- as.numeric(org.list)          #打散列表，转成向量
  org.list <- org.list[!is.na(org.list)]    #数值转换，非数值转换为NA
  cat('Sum: ', sum(org.list), '\n')         #将非NA值提取出来
}
example1(1, 'k', 'a', 'b', 3)


#―――――――――――――――――――――――――――――――――――――  二元操作符  ―――――――――――――――――――――――――――――――――――――#


# + - * / 等运算都是函数
'+'(1, 2)
1 : 10
'>'(3, 2)

# [ 也是函数
c(1 : 10)[2]
'['(1 : 10, 2)

# %in 运算符：左侧的每一个元素是否在右侧的集合中
c(1, 3, 5, 7, 9)%in% c(3, 7)
'%in%'(c(1, 3, 5, 7, 9), c(3, 7))

#自己定义二元操作符：勾股定理
'ab2c' <- function(a, b){                   #参数a和b作为输入，b默认为4
  c <- a^2 + b^2
  c <- c^0.5
  return(c)
}
'ab2c'(3, 4)


#恶作剧：重新定义 '+'

'+' <- function(x, y){
  x * y
}
2+3
rm('+')                                      #消除


